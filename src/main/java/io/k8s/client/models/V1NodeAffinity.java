/**
 * Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

package io.k8s.client.models;

import java.util.List;
import com.fasterxml.jackson.annotation.JsonProperty;

/**
 * Node affinity is a group of node affinity scheduling rules.
 */
public class V1NodeAffinity {
    /**
     * The scheduler will prefer to schedule pods to nodes that satisfy the
     * affinity expressions specified by this field, but it may choose a node
     * that violates one or more of the expressions. The node that is most
     * preferred is the one with the greatest sum of weights, i.e. for each
     * node that meets all of the scheduling requirements (resource request,
     * requiredDuringScheduling affinity expressions, etc.), compute a sum by
     * iterating through the elements of this field and adding "weight" to the
     * sum if the node matches the corresponding matchExpressions; the node(s)
     * with the highest sum are the most preferred.
     */
    @JsonProperty(value = "preferredDuringSchedulingIgnoredDuringExecution")
    private List<V1PreferredSchedulingTerm> preferredDuringSchedulingIgnoredDuringExecution;

    /**
     * If the affinity requirements specified by this field are not met at
     * scheduling time, the pod will not be scheduled onto the node. If the
     * affinity requirements specified by this field cease to be met at some
     * point during pod execution (e.g. due to an update), the system may or
     * may not try to eventually evict the pod from its node.
     */
    @JsonProperty(value = "requiredDuringSchedulingIgnoredDuringExecution")
    private V1NodeSelector requiredDuringSchedulingIgnoredDuringExecution;

    /**
     * Get the preferredDuringSchedulingIgnoredDuringExecution value.
     *
     * @return the preferredDuringSchedulingIgnoredDuringExecution value
     */
    public List<V1PreferredSchedulingTerm> preferredDuringSchedulingIgnoredDuringExecution() {
        return this.preferredDuringSchedulingIgnoredDuringExecution;
    }

    /**
     * Set the preferredDuringSchedulingIgnoredDuringExecution value.
     *
     * @param preferredDuringSchedulingIgnoredDuringExecution the preferredDuringSchedulingIgnoredDuringExecution value to set
     * @return the V1NodeAffinity object itself.
     */
    public V1NodeAffinity withPreferredDuringSchedulingIgnoredDuringExecution(List<V1PreferredSchedulingTerm> preferredDuringSchedulingIgnoredDuringExecution) {
        this.preferredDuringSchedulingIgnoredDuringExecution = preferredDuringSchedulingIgnoredDuringExecution;
        return this;
    }

    /**
     * Get the requiredDuringSchedulingIgnoredDuringExecution value.
     *
     * @return the requiredDuringSchedulingIgnoredDuringExecution value
     */
    public V1NodeSelector requiredDuringSchedulingIgnoredDuringExecution() {
        return this.requiredDuringSchedulingIgnoredDuringExecution;
    }

    /**
     * Set the requiredDuringSchedulingIgnoredDuringExecution value.
     *
     * @param requiredDuringSchedulingIgnoredDuringExecution the requiredDuringSchedulingIgnoredDuringExecution value to set
     * @return the V1NodeAffinity object itself.
     */
    public V1NodeAffinity withRequiredDuringSchedulingIgnoredDuringExecution(V1NodeSelector requiredDuringSchedulingIgnoredDuringExecution) {
        this.requiredDuringSchedulingIgnoredDuringExecution = requiredDuringSchedulingIgnoredDuringExecution;
        return this;
    }

}
